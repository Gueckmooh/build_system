package main

import (
	"fmt"
	"strings"
)

const methodSetterTemplate = `func {{.MethodName}}(L *lua.LState) int {
	self := L.ToTable(1)
	value := L.Get(2)
{{genTypeCheck .ValueType "value"}}
	L.SetField(self, "{{.FieldName}}", value)
	return 0
}
`

const methodAppendTemplate = `func {{.MethodName}}(L *lua.LState) int {
	self := L.ToTable(1)
	value := L.Get(2)
{{genTypeCheck .ValueType "value"}}
	vtable := L.GetField(self, "{{.FieldName}}")
{{genTypeCheck .TargetType "vtable"}}
	table := vtable.(*lua.LTable)
{{genAppendForTypes .ValueType "value" "table"}}
	return 0
}
`

const libraryBodyTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	lua "github.com/yuin/gopher-lua"
)

{{/* .TypeDefinition */}}

{{/* .PublicTypeDefinition */}}

{{/* .PublicGetters */}}

{{/* .ConvertLuaTable */}}

{{/* .PublicConvertLuaTable */}}

{{/* .FunctionMapping */}}

{{/* .GenIntegrityChecker */}}

{{/* .GenNewTable */}}

{{/* .GenLuaNewTable */}}

{{ .GenPublicNewTable }}

{{/* .PublicLuaNewTable */}}

// go bindings for lua methods:
{{/* - range .GoMethods */}}
{{/* . */}}
{{/* - end */}}
`

const typeCheckTemplate = `if {{ genTypeCheckCond .VarTypes .VarName }} {
	fmt.Printf("Incorrect type %s\n", {{.VarName}}.Type().String())
	L.Panic(L)
}`

const tableTypeCheckTemplate = `if {{.VarName}}.Type() == lua.LTTable {
	L.ForEach({{.VarName}}.(*lua.LTable), func (_, v lua.LValue) {
		{{ genTypeCheck .VarType "v" }}
	})
}`

// @todo remove
const typeCheckErrorTemplate = `if {{ genTypeCheckCond .VarTypes .VarName }} {
	{{.ErrName}} = fmt.Errorf("Unknown type %s", {{.VarName}}.Type().String())
}`

// @todo remove
const tableTypeCheckErrorTemplate = `if {{.VarName}}.Type() == lua.LTTable {
	var err error
	L.ForEach({{.VarName}}.(*lua.LTable), func (_, v ua.LValue) {
		var locError error
		{{ genTypeCheckError .Fields "v" "locError" }}
		if err == nil {
			err = locError
		}
	})
	if err != nil {
		return err
	}
}`

// const checkTableIntegrityTemplate = `func {{.FuncName}}(L *lua.LState, T *lua.LTable) error {
// 	{{- range .Fields}}
// 	{
// 		value := L.GetField(T, "{{.Name}}")
// 		var err error
// 		{{genTypeCheckError .Types "value" "err"}}
// 		if err != nil {
// 			return err
// 		}
// 	}
// 	{{- end}}
// 	return nil
// }`

// @todo remove
// const newTableTemplate = `func {{.FuncName}}({{.ParamsDecl}}) *lua.LTable {
// 	table := L.SetFuncs(L.NewTable(), {{.FunctionMapping}})

// 	{{genFieldsInit .Fields .Params "table"}}

// 	return table
// }`

// const luaNewTableTemplate = `func {{.FuncName}}(L *lua.LState) int {
// 	{{.ParamGets}}
// 	{{.ParamTypeChecks}}

// 	table := {{.NewFuncName}}({{.ParamsUse}})

// 	L.Push(table)

// 	return 1
// }`

const getLuaStringFromTableFieldTemplate = `var {{.VarName}} string
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	{{.VarName}} = __luaFieldValue.String()
}`

const getLuaObjectFromTableFieldTemplate = `var {{.VarName}} {{.VarType}}
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	var err error
	{{.VarName}}, err = {{.ConverterName}}(L, __luaFieldValue.(*lua.LTable))
	if err != nil {
		return nil, err
	}
}`

const getLuaStringFromValueTemplate = `{{.VarName}} := {{.LuaVarName}}.String()`

const getLuaTableFromTableFieldTemplate = `var {{.VarName}} []{{.GoType}}
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	__luaFieldTable := __luaFieldValue.(*lua.LTable)
	L.ForEach(__luaFieldTable, func(_, v lua.LValue) {
		{{genGetGoValueFromValue "__subField" "v" .Type }}
		{{.VarName}} = append({{.VarName}}, __subField)
	})
}`

const publicNewTableTemplate = `func {{.FuncName}}({{.ParamsDecl}}) *lua.LTable {
	return {{.NewTable}}({{.ParamsUse}})
}`

const publicLuaNewTableTemplate = `func {{.FuncName}}(L *lua.LState) int {
	return {{.NewTable}}(L)
}`

// @todo move
func luaTypeToGoType(ty string) string {
	switch ty {
	case "String":
		return "string"
	default:
		if typeIsTable(ty) {
			return fmt.Sprintf("[]%s", luaTypeToGoType(getInnerType(ty)))
		}
		for _, dep := range Dependencies {
			if ty == dep.TableName {
				return "*" + dep.TableTypeName
			}
		}
		return ""
	}
}

func snakeCaseToCamelCase(s string) string {
	subs := strings.Split(s, "_")
	var nsubs []string
	for _, s := range subs {
		nsubs = append(nsubs, strings.ToUpper(string(s[0]))+s[1:])
	}
	return strings.Join(nsubs, "")
}
