package main

import (
	"fmt"
	"strings"
)

const methodSetterTemplate = `func {{.MethodName}}(L *lua.LState) int {
	self := L.ToTable(1)
	value := L.Get(2)
{{genTypeCheck .ValueType "value"}}
	L.SetField(self, "{{.FieldName}}", value)
	return 0
}
`

const methodAppendTemplate = `func {{.MethodName}}(L *lua.LState) int {
	self := L.ToTable(1)
	value := L.Get(2)
{{genTypeCheck .ValueType "value"}}
	vtable := L.GetField(self, "{{.FieldName}}")
{{genTypeCheck .TargetType "vtable"}}
	table := vtable.(*lua.LTable)
{{genAppendForTypes .ValueType "value" "table"}}
	return 0
}
`

const luaFunctionMapTemplate = `var {{ .FuncMapName }} = map[string]lua.LGFunction{
{{- range .Mappings }}
	"{{ .LuaName }}": {{ .GoName }},
{{- end }}
}`

const libraryBodyTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	lua "github.com/yuin/gopher-lua"
)

{{ .TypeDefinition }}

{{ .PublicTypeDefinition }}

{{ .PublicGetters }}

{{ .ConvertLuaTable }}

{{ .PublicConvertLuaTable }}

{{ .FunctionMapping }}

{{ .IntegrityChecker }}

{{ .NewTable }}

{{ .LuaNewTable }}

{{ .PublicNewTable }}

{{ .PublicLuaNewTable }}

// go bindings for lua methods:
{{- range .GoMethods }}
{{ . }}
{{- end }}
`

const typeCheckTemplate = `if {{ genTypeCheckCond .VarTypes .VarName }} {
	fmt.Printf("Incorrect type %s\n", {{.VarName}}.Type().String())
	L.Panic(L)
}`

const tableTypeCheckTemplate = `if {{.VarName}}.Type() == lua.LTTable {
	L.ForEach({{.VarName}}.(*lua.LTable), func (_, v lua.LValue) {
		{{ genTypeCheck .VarType "v" }}
	})
}`

const typeCheckErrorTemplate = `if {{ genTypeCheckCond .VarTypes .VarName }} {
	{{.ErrName}} = fmt.Errorf("Unknown type %s", {{.VarName}}.Type().String())
}`

const tableTypeCheckErrorTemplate = `if {{.VarName}}.Type() == lua.LTTable {
	var err error
	L.ForEach({{.VarName}}.(*lua.LTable), func (_, v lua.LValue) {
		var locError error
		{{ genTypeCheckError .VarTypes "v" "locError" }}
		if err == nil {
			err = locError
		}
	})
	if err != nil {
		return err
	}
}`

const checkTableIntegrityTemplate = `func {{.FuncName}}(L *lua.LState, T *lua.LTable) error {
	{{- range .Fields}}
	{
		value := L.GetField(T, "{{.Name}}")
		var err error
		{{genTypeCheckError .Types "value" "err"}}
		if err != nil {
			return err
		}
	}
	{{- end}}
	return nil
}`

const newTableTemplate = `func {{.FuncName}}({{.ParamsDecl}}) *lua.LTable {
	table := L.SetFuncs(L.NewTable(), {{.FunctionMapping}})

	{{genFieldsInit .Fields .Params "table"}}

	return table
}`

const luaNewTableTemplate = `func {{.FuncName}}(L *lua.LState) int {
	{{.ParamGets}}
	{{.ParamTypeChecks}}

	table := {{.NewFuncName}}({{.ParamsUse}})

	L.Push(table)

	return 1
}`

const getLuaStringFromTableFieldTemplate = `var {{.VarName}} string
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	{{.VarName}} = __luaFieldValue.String()
}`

const getLuaObjectFromTableFieldTemplate = `var {{.VarName}} {{.VarType}}
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	var err error
	{{.VarName}}, err = {{.ConverterName}}(L, __luaFieldValue.(*lua.LTable))
	if err != nil {
		return nil, err
	}
}`

const getLuaStringFromValueTemplate = `{{.VarName}} := {{.LuaVarName}}.String()`

const getLuaTableFromTableFieldTemplate = `var {{.VarName}} []{{.GoType}}
{
	__luaFieldValue := L.GetField({{.TableName}}, "{{.FieldName}}")
	__luaFieldTable := __luaFieldValue.(*lua.LTable)
	L.ForEach(__luaFieldTable, func(_, v lua.LValue) {
		{{genGetGoValueFromValue "__subField" "v" .Type }}
		{{.VarName}} = append({{.VarName}}, __subField)
	})
}`

const tableConversionTemplate = `func {{.FuncName}}(L *lua.LState, T *lua.LTable) (*{{.TypeName}}, error) {
	err := {{.CheckIntegrity}}(L, T)
	if err != nil {
		return nil, err
	}
	{{- range .Fields }}
		{{genGetGoValueFromLuaField .GoName .Name "T" .Types}}
	{{- end }}

	return &{{.TypeName}}{
		{{- range .Fields }}
			{{.GoName}}: {{.GoName}},
		{{- end }}
	}, nil
}`

const publicTableGetterTemplate = `func (t *{{.TableName}}) {{.FuncName}}() {{.TypeName}} {
	return t.{{.FieldName}}
}`

const publicConvertTableTemplate = `func {{.FuncName}}(L *lua.LState, T *lua.LTable) (*{{.TableName}}, error) {
	privateTable, err := {{.ConvertName}}(L, T)
	if err != nil {
		return nil, err
	}
	publicTable := {{.TableName}}(*privateTable)
	return &publicTable, nil
}`

const publicNewTableTemplate = `func {{.FuncName}}({{.ParamsDecl}}) *lua.LTable {
	return {{.NewTable}}({{.ParamsUse}})
}`

const publicLuaNewTableTemplate = `func {{.FuncName}}(L *lua.LState) int {
	return {{.NewTable}}(L)
}`

// @todo move
func luaTypeToGoType(ty string) string {
	switch ty {
	case "String":
		return "string"
	default:
		if typeIsTable(ty) {
			return fmt.Sprintf("[]%s", luaTypeToGoType(getInnerType(ty)))
		}
		for _, dep := range Dependencies {
			if ty == dep.TableName {
				return "*" + dep.TableTypeName
			}
		}
		return ""
	}
}

func snakeCaseToCamelCase(s string) string {
	subs := strings.Split(s, "_")
	var nsubs []string
	for _, s := range subs {
		nsubs = append(nsubs, strings.ToUpper(string(s[0]))+s[1:])
	}
	return strings.Join(nsubs, "")
}

// func luaTypeToLuaGoType(ty string) string {
// 	switch ty {
// 	case "String":
// 		return "lua.LString"
// 	default:
// 		if typeIsTable(ty) {
// 			return "lua.LTable"
// 		}
// 		return ""
// 	}
// }
